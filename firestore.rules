rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---
    function isAuthenticated() {
      return request.auth != null;
    }

    // Checks if the currently authenticated user's UID matches the provided userId
    function isUser(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    // Checks if an existing document at the given path has a 'userId' field matching the current user.
    function isExistingDocOwner(docPath) {
      return isAuthenticated() && exists(docPath) && get(docPath).data.userId == request.auth.uid;
    }

    // Checks if the phpFile (identified by phpFileId) exists and is owned by the current user.
    function phpFileExistsAndIsOwned(phpFileId) {
      let phpFilePath = /databases/$(database)/documents/phpFiles/$(phpFileId);
      return isAuthenticated() && exists(phpFilePath) && get(phpFilePath).data.userId == request.auth.uid;
    }

    // Checks if the refactoringTask (identified by taskId) exists and its associated phpFile is owned by the current user.
    function refactoringTaskExistsAndIsOwned(taskId) {
      let taskPath = /databases/$(database)/documents/refactoringTasks/$(taskId);
      return isAuthenticated() && exists(taskPath) && phpFileExistsAndIsOwned(get(taskPath).data.phpFileId);
    }

    // --- Collection Rules ---

    match /users/{userId} {
      allow read: if isUser(userId);
      allow create: if isUser(userId)
                    && request.resource.data.id == userId
                    && request.resource.data.email == request.auth.token.email
                    && request.resource.data.createdAt == request.time
                    && request.resource.data.keys().hasAll(['id', 'email', 'createdAt'])
                    && (!('username' in request.resource.data) || request.resource.data.username is string); // username is optional
      allow update: if isUser(userId)
                    && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['username'])
                    && request.resource.data.username is string;
      allow delete: if false;
    }

    match /phpFiles/{fileId} {
      allow read: if isExistingDocOwner(self); // 'self' refers to the current document path
      allow create: if isUser(request.resource.data.userId) // Creator must be the owner
                    && request.resource.data.id == fileId
                    && request.resource.data.fileName is string
                    && request.resource.data.fileContent is string
                    && request.resource.data.uploadTimestamp == request.time
                    && request.resource.data.keys().hasAll(['id', 'userId', 'fileName', 'fileContent', 'uploadTimestamp']);
      allow update: if false; // PHP files are immutable
      allow delete: if isExistingDocOwner(self);
    }

    match /refactoringTasks/{taskId} {
      allow read: if refactoringTaskExistsAndIsOwned(taskId);
      allow create: if phpFileExistsAndIsOwned(request.resource.data.phpFileId)
                    && request.resource.data.id == taskId
                    && request.resource.data.originalCode is string // ensure this is present and string
                    && request.resource.data.refactoredCode is string
                    && request.resource.data.refactoringTimestamp == request.time
                    && (request.resource.data.compatibilityReportId == null || request.resource.data.compatibilityReportId is string)
                    && (request.resource.data.cloudStorageUrl == null || request.resource.data.cloudStorageUrl is string)
                    && request.resource.data.keys().hasAll(['id', 'phpFileId', 'originalCode', 'refactoredCode', 'refactoringTimestamp', 'compatibilityReportId', 'cloudStorageUrl']);
      allow update: if refactoringTaskExistsAndIsOwned(taskId) // Check ownership of existing task
                    && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['compatibilityReportId', 'cloudStorageUrl'])
                    && (request.resource.data.compatibilityReportId == null || request.resource.data.compatibilityReportId is string)
                    && (request.resource.data.cloudStorageUrl == null || request.resource.data.cloudStorageUrl is string);
      allow delete: if refactoringTaskExistsAndIsOwned(taskId);
    }

    match /compatibilityReports/{reportId} {
      allow read: if isAuthenticated() // User must be authenticated
                  // And the associated refactoring task must exist and be owned by the user
                  && exists(/databases/$(database)/documents/refactoringTasks/$(resource.data.refactoringTaskId))
                  && refactoringTaskExistsAndIsOwned(resource.data.refactoringTaskId);

      allow create: if isAuthenticated() // User must be authenticated
                    // And the associated refactoring task must exist and be owned by the user
                    && exists(/databases/$(database)/documents/refactoringTasks/$(request.resource.data.refactoringTaskId))
                    && refactoringTaskExistsAndIsOwned(request.resource.data.refactoringTaskId)
                    && request.resource.data.id == reportId
                    && request.resource.data.reportContent is string
                    && request.resource.data.generationTimestamp == request.time
                    && (request.resource.data.pdfUrl == null || request.resource.data.pdfUrl is string)
                    && (request.resource.data.cloudStorageUrl == null || request.resource.data.cloudStorageUrl is string)
                    && request.resource.data.keys().hasAll(['id', 'refactoringTaskId', 'reportContent', 'generationTimestamp', 'pdfUrl', 'cloudStorageUrl']);

      allow update: if isAuthenticated() // User must be authenticated
                    // And the associated refactoring task must exist and be owned by the user
                    && exists(/databases/$(database)/documents/refactoringTasks/$(resource.data.refactoringTaskId))
                    && refactoringTaskExistsAndIsOwned(resource.data.refactoringTaskId)
                    && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['pdfUrl', 'cloudStorageUrl'])
                    && (request.resource.data.pdfUrl == null || request.resource.data.pdfUrl is string)
                    && (request.resource.data.cloudStorageUrl == null || request.resource.data.cloudStorageUrl is string);

      allow delete: if isAuthenticated() // User must be authenticated
                    // And the associated refactoring task must exist and be owned by the user
                    && exists(/databases/$(database)/documents/refactoringTasks/$(resource.data.refactoringTaskId))
                    && refactoringTaskExistsAndIsOwned(resource.data.refactoringTaskId);
    }

    match /cloudBucketScans/{scanId} {
      allow read: if isExistingDocOwner(self);
      allow create: if isUser(request.resource.data.userId) // Creator must be the owner
                    && request.resource.data.id == scanId
                    && request.resource.data.bucketName is string
                    && (request.resource.data.directoryPath == null || request.resource.data.directoryPath is string)
                    && request.resource.data.scanTimestamp == request.time
                    && request.resource.data.phpFileIds is list
                    && request.resource.data.recursiveScan is bool
                    && request.resource.data.keys().hasAll(['id', 'userId', 'bucketName', 'scanTimestamp', 'phpFileIds', 'recursiveScan'])
                    && ( !('directoryPath' in request.resource.data) || request.resource.data.directoryPath is string); // ensure optional is string if present
      allow update: if false; // Scans are immutable
      allow delete: if isExistingDocOwner(self);
    }
  }
}
