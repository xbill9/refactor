
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Helper function to safely get document data
    function getDocData(docPath) {
      let doc = get(docPath);
      // Check if document exists and has data
      if (doc.exists && doc.data != null) {
        return doc.data;
      }
      return null; // Return null if document or data doesn't exist
    }

    function isOwnerOfDoc(collectionName, docId, userId) {
      if (docId == null || userId == null) { return false; } // Prevent error if docId or userId is null
      let docData = getDocData(/databases/$(database)/documents/$(collectionName)/$(docId));
      return docData != null && docData.userId == userId;
    }

    function isOwnerOfRelatedTask(taskId, userId) {
      if (taskId == null || userId == null) { return false; }
      let taskData = getDocData(/databases/$(database)/documents/refactoringTasks/$(taskId));
      // A task must exist and have a phpFileId
      if (taskData == null || taskData.phpFileId == null) { return false; }
      return isOwnerOfDoc('phpFiles', taskData.phpFileId, userId);
    }

    // User profiles: users can read/write their own profile
    match /users/{userId} {
      allow read, update, delete: if isAuthenticated() && request.auth.uid == userId;
      allow create: if isAuthenticated() && request.auth.uid == request.resource.data.id;
    }

    // PHP Files: users can manage their own files
    match /phpFiles/{fileId} {
      allow read, delete: if isAuthenticated() && isOwnerOfDoc('phpFiles', fileId, request.auth.uid);
      allow create: if isAuthenticated() && 
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.fileName is string &&
                       request.resource.data.fileContent is string &&
                       request.resource.data.uploadTimestamp is timestamp;
      allow update: if isAuthenticated() && 
                       isOwnerOfDoc('phpFiles', fileId, request.auth.uid) &&
                       // Allow only fileName to be updated, and userId must not change
                       request.resource.data.userId == resource.data.userId &&
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['fileName']) &&
                       (!('fileName' in request.resource.data) || request.resource.data.fileName is string);
    }

    // Refactoring Tasks: linked to PHP files, ownership derived from PHP file
    match /refactoringTasks/{taskId} {
      allow read: if isAuthenticated() && isOwnerOfRelatedTask(taskId, request.auth.uid);
      allow create: if isAuthenticated() &&
                       request.resource.data.phpFileId is string && 
                       isOwnerOfDoc('phpFiles', request.resource.data.phpFileId, request.auth.uid) &&
                       request.resource.data.refactoredCode is string &&
                       request.resource.data.refactoringTimestamp is timestamp;
      allow update: if isAuthenticated() &&
                       resource.data.phpFileId is string && // Check existing doc for ownership
                       isOwnerOfDoc('phpFiles', resource.data.phpFileId, request.auth.uid) &&
                       // Ensure only allowed fields are being modified
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['compatibilityReportId', 'cloudStorageUrl']) &&
                       // Validate compatibilityReportId ONLY IF it is part of the current update operation
                       (
                         !('compatibilityReportId' in request.resource.data) || // True if not updating this field
                         request.resource.data.compatibilityReportId is string || // or if updating, it's a string
                         request.resource.data.compatibilityReportId == null      // or if updating, it's null
                       ) &&
                       // Validate cloudStorageUrl ONLY IF it is part of the current update operation
                       (
                         !('cloudStorageUrl'in request.resource.data) ||  // True if not updating this field
                         request.resource.data.cloudStorageUrl is string || // or if updating, it's a string
                         request.resource.data.cloudStorageUrl == null       // or if updating, it's null
                       );
      allow delete: if isAuthenticated() && isOwnerOfRelatedTask(taskId, request.auth.uid);
    }

    // Compatibility Reports: linked to refactoring tasks
    match /compatibilityReports/{reportId} {
      allow read: if isAuthenticated() && 
                     resource.data.refactoringTaskId is string && 
                     isOwnerOfRelatedTask(resource.data.refactoringTaskId, request.auth.uid);
      allow create: if isAuthenticated() &&
                       request.resource.data.refactoringTaskId is string &&
                       isOwnerOfRelatedTask(request.resource.data.refactoringTaskId, request.auth.uid) &&
                       request.resource.data.reportContent is string &&
                       request.resource.data.generationTimestamp is timestamp;
      allow update: if isAuthenticated() &&
                       resource.data.refactoringTaskId is string &&
                       isOwnerOfRelatedTask(resource.data.refactoringTaskId, request.auth.uid) &&
                       // Ensure only allowed fields are being modified
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['pdfUrl', 'cloudStorageUrl']) &&
                       // Validate pdfUrl ONLY IF it is part of the current update operation
                       (
                         !('pdfUrl' in request.resource.data) ||
                         request.resource.data.pdfUrl is string ||
                         request.resource.data.pdfUrl == null
                       ) &&
                       // Validate cloudStorageUrl ONLY IF it is part of the current update operation
                       (
                         !('cloudStorageUrl' in request.resource.data) ||
                         request.resource.data.cloudStorageUrl is string ||
                         request.resource.data.cloudStorageUrl == null
                       );
      allow delete: if isAuthenticated() && 
                      resource.data.refactoringTaskId is string &&
                      isOwnerOfRelatedTask(resource.data.refactoringTaskId, request.auth.uid);
    }

    // Cloud Bucket Scans: users can manage their own scan requests
    match /cloudBucketScans/{scanId} {
      allow read, delete: if isAuthenticated() && isOwnerOfDoc('cloudBucketScans', scanId, request.auth.uid);
      allow create: if isAuthenticated() &&
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.bucketName is string &&
                       request.resource.data.scanTimestamp is timestamp &&
                       request.resource.data.phpFileIds is list &&
                       request.resource.data.recursiveScan is bool;
      // Updates to cloudBucketScans might involve adding phpFileIds by a backend process,
      // so update rules need careful consideration if users can directly update.
      // For now, restricting user updates unless specific fields are allowed.
      allow update: if isAuthenticated() && 
                       isOwnerOfDoc('cloudBucketScans', scanId, request.auth.uid) &&
                       // Example: allow updating only non-critical fields, or ensure userId doesn't change
                       request.resource.data.userId == resource.data.userId &&
                       // Add specific field update rules here if needed, e.g.,
                       // request.resource.data.diff(resource.data).affectedKeys().hasOnly(['some_field']);
                       // For now, let's assume no direct user updates or very restricted ones.
                       // This rule allows an owner to update if userId is not changed.
                       // Add more specific field checks as needed.
                       true; // Placeholder if more specific update logic is needed.
                           // If no user-updatable fields, this can be more restrictive.
    }
  }
}
