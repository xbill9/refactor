
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Function to safely get data from a document, ensuring it exists
    // Returns the document data if it exists, otherwise null (which Firestore rules treat as false in conditions)
    function getDocData(docPath) {
      let doc = get(docPath);
      if (doc.data != null) { // Check if .data itself is not null (doc exists and has data)
        return doc.data;
      }
      return null;
    }

    // Function to check if the incoming data for create/update has all required fields
    // And that userId matches the authenticated user for creations
    function hasRequiredFieldsAndValidUser(requiredFields, isCreate) {
      let allFieldsPresent = requiredFields.hasAll(request.resource.data.keys());
      if (isCreate) {
        // For create, userId must be present, a string, and match auth.uid
        return allFieldsPresent &&
               request.resource.data.userId is string &&
               request.resource.data.userId == request.auth.uid;
      }
      return allFieldsPresent; // For update, userId might not be in request.resource.data if not being changed
    }

    // User Profiles
    match /users/{userId} {
      allow create: if isAuthenticated() && request.auth.uid == userId &&
                       request.resource.data.id == userId &&
                       request.resource.data.email is string;
      allow read, update: if isOwner(userId);
      // No delete for user profiles by default
    }

    // PHP Files
    match /phpFiles/{fileId} {
      function isPhpFileOwner() {
        return resource.data.userId == request.auth.uid;
      }

      allow create: if isAuthenticated() &&
                       hasRequiredFieldsAndValidUser(['userId', 'fileName', 'fileContent', 'uploadTimestamp', 'id'], true) &&
                       request.resource.data.id == fileId &&
                       request.resource.data.fileName is string &&
                       request.resource.data.fileContent is string &&
                       request.resource.data.uploadTimestamp is timestamp; // Ensure it's a server timestamp on write
      allow read, delete: if isAuthenticated() && isPhpFileOwner();
      allow update: if isAuthenticated() && isPhpFileOwner() &&
                       // Allow only specific fields to be updated if necessary, e.g., none for now
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly([]);
    }

    // Refactoring Tasks
    match /refactoringTasks/{taskId} {
      function getPhpFileOwnerId(phpFileId) {
        let phpFileDoc = getDocData(/databases/$(database)/documents/phpFiles/$(phpFileId));
        return phpFileDoc != null ? phpFileDoc.userId : null;
      }

      function isLinkedPhpFileOwner(phpFileIdFromTask) {
        let ownerId = getPhpFileOwnerId(phpFileIdFromTask);
        return ownerId != null && isOwner(ownerId);
      }

      allow create: if isAuthenticated() &&
                       hasRequiredFieldsAndValidUser(['phpFileId', 'originalCode', 'refactoredCode', 'refactoringTimestamp', 'id', 'compatibilityReportId', 'cloudStorageUrl'], false) && // userId is not direct field here, derived from phpFileId
                       request.resource.data.id == taskId &&
                       request.resource.data.phpFileId is string &&
                       isLinkedPhpFileOwner(request.resource.data.phpFileId) &&
                       request.resource.data.originalCode is string &&
                       request.resource.data.refactoredCode is string &&
                       request.resource.data.refactoringTimestamp is timestamp &&
                       (request.resource.data.compatibilityReportId == null || request.resource.data.compatibilityReportId is string) &&
                       (request.resource.data.cloudStorageUrl == null || request.resource.data.cloudStorageUrl is string);

      allow read, delete: if isAuthenticated() && isLinkedPhpFileOwner(resource.data.phpFileId);
      allow update: if isAuthenticated() && isLinkedPhpFileOwner(resource.data.phpFileId) &&
                       // Allow updating compatibilityReportId and cloudStorageUrl
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['compatibilityReportId', 'cloudStorageUrl']) &&
                       (request.resource.data.compatibilityReportId == null || request.resource.data.compatibilityReportId is string) &&
                       (request.resource.data.cloudStorageUrl == null || request.resource.data.cloudStorageUrl is string);
    }

    // Compatibility Reports
    match /compatibilityReports/{reportId} {
      function getTaskOwnerIdViaPhpFile(taskId) {
        let taskDoc = getDocData(/databases/$(database)/documents/refactoringTasks/$(taskId));
        if (taskDoc != null && taskDoc.phpFileId is string) {
          return getPhpFileOwnerId(taskDoc.phpFileId); // Re-use phpFile owner check
        }
        return null;
      }

      function isLinkedTaskOwner(taskIdFromReport) {
         let ownerId = getTaskOwnerIdViaPhpFile(taskIdFromReport);
         return ownerId != null && isOwner(ownerId);
      }

      allow create: if isAuthenticated() &&
                       hasRequiredFieldsAndValidUser(['refactoringTaskId', 'reportContent', 'generationTimestamp', 'id', 'pdfUrl', 'cloudStorageUrl'], false) && // No direct userId
                       request.resource.data.id == reportId &&
                       request.resource.data.refactoringTaskId is string &&
                       isLinkedTaskOwner(request.resource.data.refactoringTaskId) &&
                       request.resource.data.reportContent is string &&
                       request.resource.data.generationTimestamp is timestamp &&
                       (request.resource.data.pdfUrl == null || request.resource.data.pdfUrl is string) &&
                       (request.resource.data.cloudStorageUrl == null || request.resource.data.cloudStorageUrl is string);

      allow read, delete: if isAuthenticated() && isLinkedTaskOwner(resource.data.refactoringTaskId);
      allow update: if isAuthenticated() && isLinkedTaskOwner(resource.data.refactoringTaskId) &&
                       // Allow updating pdfUrl and cloudStorageUrl
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['pdfUrl', 'cloudStorageUrl']) &&
                       (request.resource.data.pdfUrl == null || request.resource.data.pdfUrl is string) &&
                       (request.resource.data.cloudStorageUrl == null || request.resource.data.cloudStorageUrl is string);
    }

    // Cloud Bucket Scans
    match /cloudBucketScans/{scanId} {
      function isBucketScanOwner() {
        return resource.data.userId == request.auth.uid;
      }
      allow create: if isAuthenticated() &&
                       hasRequiredFieldsAndValidUser(['userId', 'bucketName', 'scanTimestamp', 'phpFileIds', 'recursiveScan', 'id'], true) &&
                       request.resource.data.id == scanId &&
                       request.resource.data.bucketName is string &&
                       request.resource.data.scanTimestamp is timestamp &&
                       request.resource.data.phpFileIds is list &&
                       request.resource.data.recursiveScan is bool &&
                       (request.resource.data.directoryPath == null || request.resource.data.directoryPath is string);

      allow read: if isAuthenticated() && isBucketScanOwner();
      // No update or delete for bucket scans by default.
    }
  }
}
